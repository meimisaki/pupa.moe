'use strict';

var Syncher = require('../../syncher');

function selectObjects(key) {
	var last = key.split(':').pop();
	var args = Array.prototype.slice.call(arguments, 1);
	var callback = args.pop();
	var opts = args.pop() || {};
	var limit = opts.limit === undefined ? 10 : opts.limit;
	if (!limit) return callback(null, []);
	var client = this;
	var offset = opts.offset || 0;
	var keyword = (opts.keyword || '').toLowerCase();
	function map(err, out) {
		if (err) return callback(err);
		var syncher = new Syncher();
		out.forEach(function (val) {
			syncher.add(client.getObject.bind(client, last, val));
		});
		syncher.run(function () {
			for (var key = 0 ; key < arguments.length ; ++key) {
				var err = arguments[key][0];
				if (err) return callback(err);
				out[key] = arguments[key][1];
			}
			callback(null, out);
		});
	}
	if (!keyword) return client._.zrevrange(key + '-list' , offset, limit < 0 ? -1 : offset + limit - 1, map);
	function iter(out, start, step) {
		var end = start + step;
		client._.zrevrange(key + '-list', start, end, function (err, replies) {
			if (err) return map(err);
			var syncher = new Syncher();
			replies.forEach(function (val) {
				syncher.add(client._.sismember.bind(client._, last + ':' + val + '@index', keyword));
			});
			syncher.run(function () {
				for (var key = 0 ; key < replies.length ; ++key)
					if (!arguments[key][0] && arguments[key][1])
						out.push(replies[key]);
				if (limit >= 0 && replies.length == step + 1 && out.length < offset + limit) iter(out, end + 1, step + 1);
				else map(null, out.slice(offset, limit < 0 ? out.length : offset + limit));
			});
		});
	}
	iter([], 0, limit < 0 ? -1 : Math.ceil(Math.sqrt(offset + limit)));
}

module.exports = selectObjects;
